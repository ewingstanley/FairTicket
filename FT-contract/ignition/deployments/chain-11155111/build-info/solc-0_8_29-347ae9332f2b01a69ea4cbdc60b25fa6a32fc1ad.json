{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_29-347ae9332f2b01a69ea4cbdc60b25fa6a32fc1ad",
  "solcVersion": "0.8.29",
  "solcLongVersion": "0.8.29+commit.ab55807c",
  "userSourceNameMap": {
    "contracts/fair_ticket.sol": "project/contracts/fair_ticket.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/Hashes.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/Hashes.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library of standard hash functions.\n *\n * _Available since v5.1._\n */\nlibrary Hashes {\n    /**\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\n     *\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n     */\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\n        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/MerkleProof.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MerkleProof.sol)\n// This file was procedurally generated from scripts/generate/templates/MerkleProof.js.\n\npragma solidity ^0.8.20;\n\nimport {Hashes} from \"./Hashes.sol\";\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n *\n * IMPORTANT: Consider memory side-effects when using custom hashing functions\n * that access memory in an unsafe way.\n *\n * NOTE: This library supports proof verification for merkle trees built using\n * custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\n * leaf inclusion in trees built using non-commutative hashing functions requires\n * additional logic that is not supported by this library.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProof(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function processProof(\n        bytes32[] memory proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProofCalldata(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function processProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n}\n"
      },
      "project/contracts/fair_ticket.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.29;\r\n\r\nimport {Project, Participant, LotteryResult, ProjectStatus} from \"./Model.sol\";\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\n\r\n// 使用openzeppelin封装的Ownable合约进行合约的权限控制。contract XX is YY 相当于XX合约继承了YY合约的一些属性和功能，可以在XX合约中直接使用。\r\ncontract FairTicket is Ownable {\r\n    //// State Variables ////\r\n    uint256 public s_globalId;\r\n    mapping(uint256 => Project) public s_pid2project;\r\n    mapping(uint256 => Participant[]) public s_projectid_participants;\r\n    mapping(uint256 => mapping(address => Participant))\r\n        public s_projectid_paddr_participant;\r\n    mapping(uint256 => LotteryResult) public s_projectid_lottery;\r\n\r\n    //// Events ////\r\n    event ProjectCreated(\r\n        uint256 indexed projectId,\r\n        bytes32 indexed fingerprint\r\n    );\r\n    event ProjectStarted(uint256 indexed projectId);\r\n    event ProjectFinished(uint256 indexed projectId);\r\n    event MagicNumberPublished(uint256 indexed projectId, uint256 magicNumber);\r\n\r\n    //// Errors ////\r\n    error ProjectNotFound();\r\n    error ProjectAlreadyStarted();\r\n    error ProjectNotInProgress();\r\n    error ProjectNotFinished();\r\n    error TotalSupplyZero();\r\n    error OnlyProjectOwner();\r\n    error MerkleRootAlreadySet();\r\n    error OffsetOutOfBounds();\r\n    error MerkleProofInvalid(\r\n        uint256 projectId,\r\n        address sender,\r\n        bytes32 self,\r\n        bytes32[] proof\r\n    );\r\n\r\n    // 继承了Ownable合约要初始化。这里将合约的创建者设置为该合约的owner。\r\n    constructor(uint256 _globalId) Ownable(msg.sender) {\r\n        s_globalId = _globalId;\r\n    }\r\n\r\n    //// Modifiers ////\r\n    // 项目存在验证修饰器\r\n    modifier projectExist(uint256 _projectId) {\r\n        if (s_pid2project[_projectId].id == 0) revert ProjectNotFound();\r\n        _;\r\n    }\r\n\r\n    // 项目所有者验证修饰器\r\n    modifier projectOwnerOnly(uint256 _projectId) {\r\n        if (s_pid2project[_projectId].owner != msg.sender)\r\n            revert OnlyProjectOwner();\r\n        _;\r\n    }\r\n\r\n    // 项目进行中验证修饰器\r\n    modifier projectInProgress(uint256 _projectId) {\r\n        if (s_pid2project[_projectId].projectStatus != ProjectStatus.InProgress)\r\n            revert ProjectNotInProgress();\r\n        _;\r\n    }\r\n\r\n    // 项目结束验证修饰器\r\n    modifier projectFinished(uint256 _projectId) {\r\n        if (s_pid2project[_projectId].projectStatus != ProjectStatus.Finished)\r\n            revert ProjectNotFinished();\r\n        _;\r\n    }\r\n\r\n    //// Functions ////\r\n\r\n    // 创建项目函数\r\n    // 这里使用了onlyOwner修饰器，保证只有合约所有者可以执行该函数 这个onlyOwner修饰器是来自openzeppelin的Ownable.sol\r\n    function createProject(\r\n        bytes32 _fingerprint,\r\n        address _owner,\r\n        uint256 _totalSupply\r\n    ) public onlyOwner {\r\n        if (_totalSupply == 0) revert TotalSupplyZero();\r\n        // 创建新项目\r\n        Project memory newProject = Project({\r\n            id: s_globalId,\r\n            fingerprint: _fingerprint,\r\n            owner: _owner,\r\n            totalSupply: _totalSupply,\r\n            projectStatus: ProjectStatus.NotStart,\r\n            merkleRoot: bytes32(0)\r\n        });\r\n        // 将新项目信息存储到mappings中 并且将全局项目id+1\r\n        s_pid2project[newProject.id] = newProject;\r\n        s_globalId += 1;\r\n        // 触发项目创建事件\r\n        emit ProjectCreated(newProject.id, _fingerprint);\r\n    }\r\n\r\n    // 参与项目函数\r\n    function participate(\r\n        uint256 _projectId,\r\n        address _addr,\r\n        uint256 _luckyNum\r\n    ) public projectExist(_projectId) projectInProgress(_projectId) {\r\n        Participant memory newParticipant = Participant({\r\n            addr: _addr,\r\n            luckyNum: _luckyNum\r\n        });\r\n        s_projectid_participants[_projectId].push(newParticipant);\r\n        s_projectid_paddr_participant[_projectId][_addr] = newParticipant;\r\n    }\r\n\r\n    // 开始项目函数\r\n    // 这里使用了ProjectExist和onlyOwner修饰器\r\n    function startProject(\r\n        uint256 _projectId\r\n    ) public projectExist(_projectId) onlyOwner {\r\n        if (s_pid2project[_projectId].projectStatus != ProjectStatus.NotStart)\r\n            revert ProjectAlreadyStarted();\r\n        // 将项目状态设置为进行中\r\n        s_pid2project[_projectId].projectStatus = ProjectStatus.InProgress;\r\n        // 触发项目开始事件\r\n        emit ProjectStarted(_projectId);\r\n    }\r\n\r\n    // 结束项目函数\r\n    // 这里使用了ProjectExist和onlyOwner修饰器\r\n    function finishProject(\r\n        uint256 _projectId\r\n    ) public onlyOwner projectExist(_projectId) {\r\n        if (s_pid2project[_projectId].projectStatus != ProjectStatus.InProgress)\r\n            revert ProjectNotInProgress();\r\n        // 将项目状态设置为结束\r\n        s_pid2project[_projectId].projectStatus = ProjectStatus.Finished;\r\n        // 触发项目结束事件\r\n        emit ProjectFinished(_projectId);\r\n    }\r\n\r\n    // 抽奖函数\r\n    // 这里使用了ProjectExist和onlyOwner,projectFinished修饰器\r\n    function lottery(\r\n        uint256 _projectId\r\n    ) public onlyOwner projectExist(_projectId) projectFinished(_projectId) {\r\n        // 生成随机数\r\n        uint256 magicNumber = SimpleMock.simpleVRF();\r\n        // 创建抽奖结果\r\n        LotteryResult memory result = LotteryResult({\r\n            projectId: _projectId,\r\n            magicNumber: magicNumber\r\n        });\r\n        // 将抽奖结果存储到mappings中\r\n        s_projectid_lottery[_projectId] = result;\r\n        // 触发抽奖结果发布事件\r\n        emit MagicNumberPublished(_projectId, magicNumber);\r\n    }\r\n\r\n    // 设置MerkleRoot函数\r\n    // 这里使用了onlyOwner修饰器，保证只有合约所有者可以执行该函数\r\n    function SetMerkleRoot(\r\n        uint256 _projectId,\r\n        bytes32 _merkleRoot\r\n    ) public onlyOwner {\r\n        if (s_pid2project[_projectId].merkleRoot != bytes32(0))\r\n            revert MerkleRootAlreadySet();\r\n        // 设置MerkleRoot\r\n        s_pid2project[_projectId].merkleRoot = _merkleRoot;\r\n    }\r\n\r\n    // 验证MerkleProof函数\r\n    function verifyMerkleProof(\r\n        uint256 _prjectId,\r\n        bytes32[] memory proof\r\n    ) public view returns (bool) {\r\n        // 获取当前调用者的地址\r\n        // address是一个bytes20类型 而keccak256的输入参数是bytes32类型\r\n        // 因此需要abi.encodePacked 将msg.sender打包成bytes32类型 然后使用keccak256计算哈希值\r\n        bytes32 self = keccak256(abi.encodePacked(msg.sender));\r\n        // 验证MerkleProof 使用的是openzeppelin的MerkleProof库\r\n        bool result = MerkleProof.verify(\r\n            proof,\r\n            s_pid2project[_prjectId].merkleRoot,\r\n            self\r\n        );\r\n        if (!result) {\r\n            revert MerkleProofInvalid(_prjectId, msg.sender, self, proof);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    ///// Getters /////\r\n    // 这里的Getters虽然可能某些函数不被业务需要 但如果不返回 在使用abi编译成go文件时，可能会缺失某些结构体\r\n\r\n    // 分页获取参与者的函数\r\n    // 参与者或许会很多，受到节点，网络等各种限制，不可能一次返回项目的所有参与者，所以需要分页获取\r\n    function getProjectParticipants(\r\n        uint256 _projectId,\r\n        uint256 _offset,\r\n        uint256 _limit\r\n    ) public view returns (Participant[] memory) {\r\n        uint256 totalParticipants = s_projectid_participants[_projectId].length;\r\n        // 确保 offset 有效\r\n        if (_offset >= totalParticipants) revert OffsetOutOfBounds();\r\n        // 计算实际要返回的数量\r\n        uint256 actualLimit = _limit;\r\n        if (_offset + _limit > totalParticipants) {\r\n            actualLimit = totalParticipants - _offset;\r\n        }\r\n        // 创建结果数组\r\n        Participant[] memory result = new Participant[](actualLimit);\r\n        for (uint256 i = 0; i < actualLimit; i++) {\r\n            result[i] = s_projectid_participants[_projectId][_offset + i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getProjectInfo(\r\n        uint256 _projectId\r\n    ) public view returns (Project memory) {\r\n        return s_pid2project[_projectId];\r\n    }\r\n\r\n    function getProjectStatus(\r\n        uint256 _projectId\r\n    ) public view returns (ProjectStatus) {\r\n        return s_pid2project[_projectId].projectStatus;\r\n    }\r\n\r\n    function getLotteryResult(\r\n        uint256 _projectId\r\n    ) public view returns (LotteryResult memory) {\r\n        return s_projectid_lottery[_projectId];\r\n    }\r\n\r\n    function getParticipantInfo(\r\n        uint256 _projectId,\r\n        address _addr\r\n    ) public view returns (Participant memory) {\r\n        return s_projectid_paddr_participant[_projectId][_addr];\r\n    }\r\n\r\n    function getProjectParticipantsAmount(\r\n        uint256 _projectId\r\n    ) public view returns (uint256) {\r\n        return s_projectid_participants[_projectId].length;\r\n    }\r\n\r\n    function getMagicNumber(uint256 _projectId) public view returns (uint256) {\r\n        return s_projectid_lottery[_projectId].magicNumber;\r\n    }\r\n}\r\n\r\n// 一个简单的mock库，用于生成随机数\r\n// 实际中应该调用链上合约的随机数生成函数，为了简单，这里就不介绍Chainlink VRF相关知识，也不打算编写VRF的Mock合约，而是直接提供一个返回值\r\n// 函数声明为 internal 内联函数，防止部署时单独部署\r\nlibrary SimpleMock {\r\n    function simpleVRF() internal pure returns (uint256) {\r\n        return 1234567890;\r\n    }\r\n}\r\n"
      },
      "project/contracts/Model.sol": {
        "content": "pragma solidity ^0.8;\r\n\r\n// Project struct\r\nstruct Project {\r\n    // id 合约中递增的项目id\r\n    uint256 id;\r\n    // fingerprint 由后端生成，存在数据库里，在创建项目时传入，为了建立数据库与合约中的项目的关联\r\n    bytes32 fingerprint;\r\n    // owner 项目的拥有者，可以进行状态修改\r\n    address owner;\r\n    // totalSupply 项目的票数供应\r\n    uint256 totalSupply;\r\n    // projectStatus 项目当前状态\r\n    ProjectStatus projectStatus;\r\n    // merkleRoot 项目的merkleRoot，在抽票完成后，根据中奖者构建Merkle树进行生成\r\n    bytes32 merkleRoot;\r\n}\r\n\r\n// projectStatus 项目状态\r\nenum ProjectStatus {\r\n    NotStart,\r\n    InProgress,\r\n    Finished\r\n}\r\n\r\n// Participant 参与者的信息 记录地址以及设置的幸运数字\r\nstruct Participant {\r\n    address addr;\r\n    uint256 luckyNum;\r\n}\r\n\r\n// LotteryResult 记录项目的抽票依据\r\nstruct LotteryResult {\r\n    uint256 projectId;\r\n    // magicNumber 链上随机数，可使用ChainLink的VRF进行可靠随机数生成\r\n    uint256 magicNumber;\r\n}"
      }
    }
  }
}